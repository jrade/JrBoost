
main                      4072   3.1%
  t-rank                  4889   3.7%    4.4
  train boost            15196  11.5%   19.5
  train stumps
    validate                57   0.0%    0.6
    used samples          7560   5.7%    9.7
    used variables        4036   3.0%   12.6
    sums                   695   0.5%    9.4
    sorted used s.       64107  48.4%    3.4
    best split           28188  21.3%   13.3
  predict                 1423   1.1%
  OMP barrier              315   0.2%
  dyn. memory             1910   1.4%  399.5

zero calibration: 62
profiling overhead: 18.9%
slow branch: 2.6%

0:01:19

---------------------------------------------------------------------

using size_t and double everywhere
	except:
		arrays of sampleIndices use smallest type
		inData: float

	profile the first decision again

=====================================================================

C++:
	do some micro-optimizations? is it even possible?
		sums in partcular
		ideas
			move things into local varables
			access arrays through raw poiners
				how to get pointer to buffer of Eigen::CRef object?

	review zero calibration of profiling again
		maybe manual calibration is better?

python:
	clean repo
		find suitable dataset on Kaggle?
		push to GitHub

	produce report
		first a simple one
		add a train and predict function similar to train and eval

	Pandas free Python code

	implement smarter hyperparameter optimization methods

-----------------------------------------------------------------------

gradient boost
	read xgb paper to check that my understanding is correct

trees
	allocate nodes with a memory pool
	pruning

data members of boosters should be const
	can not iterate over const Eigen Ref object!!!!

test PGO

extended algorithms:
	check if alpha boost idea works
	first and second order boost
	alpha boost
	alpha-beta boost with beta loss

review use of integer and foating point data types

stump train strategy:
	current method has time complexity (in clock cycles)
		3.4 * sampleCount * usedVariableCount + 13.3 * usedSampleCount * usedVariableCount
	there is an alternative method with time complexity
		a * usedSampleCount * log(usedSampleCount) * usedVariableCount + 13.3 * usedSampleCount * usedVariableCunt
	create a used sample list and sort it each time
	this might be faster when usedSampleCount is small i.e. when we do weight filtering and most weights are small
	use pdq-sort (https://github.com/orlp/pdqsort) when sorting

histogram based methods

----------------------------------------------------------------------

low prio:
	look in the old stub (or rather tree) builder code and see how I avoided rounding off errors towards the end
	L2-penalty (lambda) or L1-penalty (alpha)
	multi-group

----------------------------------------------------------------------

PyBind11 issues:
	how translate custom C++ exceptions to standard Python exceptions
	no way of specifying noocnvert for property setters
	investigate abstract factory crash (JrBooster Crash)
		is the problem return values that are derived objects passed with unique_ptr to base class?
		test with the Miniconda that somes bundles with Visual Studio
	
Gerstmann issues:
	seed function would be useful
	free functions (operator== and operator!=) should be inline
		or linker will complain if you include the header in multiple translation units
	should be standard compliant

Eigen issues:
	can not reset Ref objects
	no select with two constants
	    StumpTrainerImpl(CRefXXf inData, RefXs strata)
			second argument should be CRefXs, but that leads to problems ...

	Eigen::Ref<Eigen::ArrayXf> u;
	auto p1 = u.begin();
	auto p2 = begin(u);
	auto p3 = u.cbegin();
	auto p4 = cbegin(u);
	float* p5 = &u(0);

	Eigen::Ref<Eigen::ArrayXf> u;
	auto q1 = u.cbegin();
	auto q2 = cbegin(u);
	const float* q3 = &u(0);

	also reverse iterators

NumPy issues:
	inData[trainSamples, :] does not preserve Fortran (column major) order

------------------------------------------------------------------------

take a look at std::span, std::view, std::mdview, ranges etc in C++20

